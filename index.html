<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoTessera Interactive Classifier</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        #map {
            flex: 1;
            position: relative;
        }
        
        .controls {
            width: 320px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #444;
        }
        
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background: #333;
            border-radius: 8px;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input, select, button {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #555;
            border-radius: 4px;
            background: #444;
            color: #fff;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        button {
            background: #4CAF50;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .class-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            padding: 8px;
            background: #444;
            border-radius: 4px;
        }
        
        .class-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #fff;
            flex-shrink: 0;
        }
        
        .class-info {
            flex: 1;
            min-width: 0;
        }
        
        .class-name {
            font-size: 12px;
            font-weight: bold;
        }
        
        .class-count {
            font-size: 10px;
            color: #aaa;
        }
        
        .class-actions {
            display: flex;
            gap: 5px;
        }
        
        .class-actions button {
            width: auto;
            padding: 4px 8px;
            font-size: 10px;
            margin: 0;
        }
        
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .status.loading {
            background: #4CAF50;
            color: white;
        }
        
        .status.error {
            background: #f44336;
            color: white;
        }
        
        .status.success {
            background: #2196F3;
            color: white;
        }
        
        .visualization-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        
        .visualization-controls select {
            width: auto;
            flex: 1;
        }
        
        .embedding-info {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 11px;
            color: #ccc;
        }
        
        .mode-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .mode-button {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #555;
            background: #444;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .mode-button.active {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        
        .advanced-controls {
            margin-top: 10px;
        }
        
        .slider-group {
            margin: 10px 0;
        }
        
        .slider-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
        }
        
        .slider-value {
            font-size: 11px;
            color: #aaa;
            text-align: right;
        }
        
        .api-config {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        
        .api-config input {
            font-size: 11px;
        }
        
        .classification-method {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }
        
        .classification-method select {
            flex: 1;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #444;
            border-radius: 2px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        
        .leaflet-control-layers {
            background: #333 !important;
            color: #fff !important;
        }
        
        .leaflet-control-layers-list {
            color: #fff !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="map"></div>
        <div class="controls">
            <div class="control-group">
                <h3>üîß API Configuration</h3>
                <div class="api-config">
                    <input type="text" id="apiBase" placeholder="API Base URL (e.g., https://your-app.vercel.app)" value="">
                    <small style="color: #aaa; font-size: 10px;">Leave empty for local development (localhost:3000)</small>
                </div>
            </div>
            
            <div class="control-group">
                <h3>üìç Location</h3>
                <input type="number" id="latInput" placeholder="Latitude" step="0.01" value="52.05">
                <input type="number" id="lonInput" placeholder="Longitude" step="0.01" value="0.15">
                <input type="number" id="yearInput" placeholder="Year" value="2024">
                <button id="loadLocation">Load GeoTessera Embeddings</button>
            </div>
            
            <div class="control-group">
                <h3>üé® Visualization</h3>
                <div class="visualization-controls">
                    <select id="bandR">
                        <option value="0">Band 0</option>
                    </select>
                    <select id="bandG">
                        <option value="1">Band 1</option>
                    </select>
                    <select id="bandB">
                        <option value="2">Band 2</option>
                    </select>
                </div>
                <button id="updateVisualization">Update Visualization</button>
                <label>
                    <input type="checkbox" id="normalizeVis" checked> Normalize bands
                </label>
            </div>
            
            <div class="control-group">
                <h3>üîç Classification</h3>
                <div class="mode-selector">
                    <button class="mode-button active" data-mode="train">Train</button>
                    <button class="mode-button" data-mode="classify">Classify</button>
                </div>
                
                <div class="classification-method">
                    <select id="classificationMethod">
                        <option value="knn">K-Nearest Neighbors</option>
                        <option value="kmeans">K-Means Clustering</option>
                    </select>
                </div>
                
                <div class="advanced-controls">
                    <div class="slider-group">
                        <label>Distance Threshold (KNN)</label>
                        <input type="range" id="threshold" min="0.1" max="2.0" step="0.1" value="0.5">
                        <div class="slider-value" id="thresholdValue">0.5</div>
                    </div>
                    <div class="slider-group">
                        <label>Number of Clusters (K-Means)</label>
                        <input type="range" id="nClusters" min="2" max="10" step="1" value="5">
                        <div class="slider-value" id="nClustersValue">5</div>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <h3>üìä Classes</h3>
                <input type="text" id="newClassName" placeholder="New class name">
                <button id="addClass">Add Class</button>
                <div id="classList"></div>
                <button id="clearClasses">Clear Classes</button>
            </div>
            
            <div class="control-group">
                <h3>‚ö° Actions</h3>
                <button id="classifyAll">Classify All Pixels</button>
                <button id="exportResults">Export Results</button>
                <div class="progress-bar" id="progressBar" style="display: none;">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div id="status" class="status" style="display: none;"></div>
            
            <div class="embedding-info">
                <strong>GeoTessera Embeddings</strong><br>
                <span id="embeddingDetails">Load a location to see embedding details</span>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        class GeoTesseraClassifier {
            constructor() {
                this.updateClassDisplay();
                this.showStatus('All classes cleared', 'success');
            }
            
            exportResults() {
                if (!this.classificationResults) {
                    this.showStatus('No classification results to export', 'error');
                    return;
                }
                
                const results = {
                    location: this.currentLocation,
                    classes: this.classes,
                    training_data: this.trainingData,
                    classification_results: this.classificationResults.classification,
                    classification_stats: this.classificationResults.class_stats,
                    embedding_info: this.embeddingData,
                    export_timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `geotessera_classification_${this.currentLocation.lat}_${this.currentLocation.lon}_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.showStatus('Results exported successfully', 'success');
            }
            
            showStatus(message, type) {
                const statusDiv = document.getElementById('status');
                statusDiv.textContent = message;
                statusDiv.className = `status ${type}`;
                statusDiv.style.display = 'block';
                
                if (type === 'success' || type === 'error') {
                    setTimeout(() => {
                        statusDiv.style.display = 'none';
                    }, 3000);
                }
            }
            
            showProgress(percent) {
                const progressBar = document.getElementById('progressBar');
                const progressFill = document.getElementById('progressFill');
                progressBar.style.display = 'block';
                progressFill.style.width = `${percent}%`;
            }
            
            hideProgress() {
                const progressBar = document.getElementById('progressBar');
                progressBar.style.display = 'none';
            }
        }
        
        // Global reference for onclick handlers
        let classifier;
        
        // Initialize the application after Leaflet is loaded
        function initializeApp() {
            if (typeof L !== 'undefined') {
                classifier = new GeoTesseraClassifier();
            } else {
                // Wait a bit more for Leaflet to load
                setTimeout(initializeApp, 100);
            }
        }
        
        // Start initialization
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>.map = null;
                this.embeddingData = null;
                this.embeddingLayer = null;
                this.classificationLayer = null;
                this.currentMode = 'train';
                this.classes = [];
                this.trainingData = [];
                this.classificationResults = null;
                this.selectedClass = null;
                this.currentLocation = null;
                this.markers = [];
                
                this.initializeMap();
                this.setupEventListeners();
                this.updateClassDisplay();
                this.populateBandSelectors();
            }
            
            getApiBase() {
                const apiBase = document.getElementById('apiBase').value.trim();
                return apiBase || 'http://localhost:3000';
            }
            
            initializeMap() {
                this.map = L.map('map').setView([52.05, 0.15], 13);
                
                // Add OpenStreetMap base layer
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(this.map);
                
                // Add click handler for training/classification
                this.map.on('click', (e) => {
                    this.handleMapClick(e);
                });
            }
            
            setupEventListeners() {
                document.getElementById('loadLocation').addEventListener('click', () => {
                    this.loadEmbeddings();
                });
                
                document.getElementById('updateVisualization').addEventListener('click', () => {
                    this.updateVisualization();
                });
                
                document.getElementById('addClass').addEventListener('click', () => {
                    this.addClass();
                });
                
                document.getElementById('clearClasses').addEventListener('click', () => {
                    this.clearClasses();
                });
                
                document.getElementById('classifyAll').addEventListener('click', () => {
                    this.classifyAllPixels();
                });
                
                document.getElementById('exportResults').addEventListener('click', () => {
                    this.exportResults();
                });
                
                // Mode selector
                document.querySelectorAll('.mode-button').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.mode-button').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentMode = e.target.dataset.mode;
                    });
                });
                
                // Threshold slider
                document.getElementById('threshold').addEventListener('input', (e) => {
                    document.getElementById('thresholdValue').textContent = e.target.value;
                });
                
                // Clusters slider
                document.getElementById('nClusters').addEventListener('input', (e) => {
                    document.getElementById('nClustersValue').textContent = e.target.value;
                });
                
                // Enter key for class name
                document.getElementById('newClassName').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.addClass();
                    }
                });
            }
            
            populateBandSelectors() {
                const selectors = ['bandR', 'bandG', 'bandB'];
                const defaults = [0, 1, 2];
                
                selectors.forEach((id, index) => {
                    const select = document.getElementById(id);
                    select.innerHTML = '';
                    for (let i = 0; i < 128; i++) {
                        const option = document.createElement('option');
                        option.value = i;
                        option.textContent = `Band ${i}`;
                        if (i === defaults[index]) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    }
                });
            }
            
            async loadEmbeddings() {
                const lat = parseFloat(document.getElementById('latInput').value);
                const lon = parseFloat(document.getElementById('lonInput').value);
                const year = parseInt(document.getElementById('yearInput').value);
                
                if (isNaN(lat) || isNaN(lon) || isNaN(year)) {
                    this.showStatus('Please enter valid coordinates and year', 'error');
                    return;
                }
                
                this.showStatus('Loading GeoTessera embeddings...', 'loading');
                
                try {
                    const apiBase = this.getApiBase();
                    const response = await fetch(`${apiBase}/api/load_embedding?lat=${lat}&lon=${lon}&year=${year}`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error(result.error);
                    }
                    
                    this.embeddingData = result.data;
                    this.currentLocation = { lat, lon, year };
                    
                    // Update map center and zoom to show the tile area
                    this.map.setView([lat + 0.05, lon + 0.05], 12);
                    
                    // Update embedding info
                    const info = this.embeddingData;
                    document.getElementById('embeddingDetails').innerHTML = 
                        `Location: ${lat.toFixed(3)}, ${lon.toFixed(3)}<br>
                         Year: ${year}<br>
                         Original: ${info.original_shape[0]} √ó ${info.original_shape[1]}<br>
                         Channels: ${info.original_shape[2]}<br>
                         Downsampled: ${info.downsampled_shape[0]} √ó ${info.downsampled_shape[1]}<br>
                         Coverage: ~0.1¬∞ √ó 0.1¬∞ (~10km √ó 10km)`;
                    
                    // Load initial visualization
                    await this.updateVisualization();
                    
                    this.showStatus('GeoTessera embeddings loaded successfully!', 'success');
                    
                } catch (error) {
                    console.error('Error loading embeddings:', error);
                    this.showStatus(`Error loading embeddings: ${error.message}`, 'error');
                }
            }
            
            async updateVisualization() {
                if (!this.embeddingData || !this.currentLocation) {
                    this.showStatus('Please load embeddings first', 'error');
                    return;
                }
                
                const rBand = parseInt(document.getElementById('bandR').value);
                const gBand = parseInt(document.getElementById('bandG').value);
                const bBand = parseInt(document.getElementById('bandB').value);
                const normalize = document.getElementById('normalizeVis').checked;
                
                this.showStatus('Generating visualization...', 'loading');
                
                try {
                    const apiBase = this.getApiBase();
                    const response = await fetch(`${apiBase}/api/visualize_bands`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            lat: this.currentLocation.lat,
                            lon: this.currentLocation.lon,
                            year: this.currentLocation.year,
                            bands: [rBand, gBand, bBand],
                            normalize: normalize
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error(result.error);
                    }
                    
                    // Remove existing embedding layer
                    if (this.embeddingLayer) {
                        this.map.removeLayer(this.embeddingLayer);
                    }
                    
                    // Add new embedding layer with correct bounds (0.1 degree tile)
                    const bounds = [
                        [this.currentLocation.lat, this.currentLocation.lon],
                        [this.currentLocation.lat + 0.1, this.currentLocation.lon + 0.1]
                    ];
                    
                    this.embeddingLayer = L.imageOverlay(result.data.image, bounds, {
                        opacity: 0.8,
                        interactive: true
                    }).addTo(this.map);
                    
                    this.showStatus('Visualization updated', 'success');
                    
                } catch (error) {
                    console.error('Error updating visualization:', error);
                    this.showStatus(`Error updating visualization: ${error.message}`, 'error');
                }
            }
            
            async handleMapClick(e) {
                if (!this.embeddingData || !this.currentLocation) {
                    this.showStatus('Please load embeddings first', 'error');
                    return;
                }
                
                // Convert lat/lon to pixel coordinates within the 0.1 degree tile
                const { lat, lon } = this.currentLocation;
                const tileLatStart = lat;
                const tileLonStart = lon;
                const tileLatEnd = lat + 0.1;
                const tileLonEnd = lon + 0.1;
                
                // Check if click is within the tile bounds
                if (e.latlng.lat < tileLatStart || e.latlng.lat > tileLatEnd ||
                    e.latlng.lng < tileLonStart || e.latlng.lng > tileLonEnd) {
                    this.showStatus('Please click within the embedding tile area', 'error');
                    return;
                }
                
                // Convert to pixel coordinates
                const [height, width] = this.embeddingData.original_shape;
                const x = Math.floor((e.latlng.lng - tileLonStart) / 0.1 * width);
                const y = Math.floor((e.latlng.lat - tileLatStart) / 0.1 * height);
                
                if (this.currentMode === 'train') {
                    this.addTrainingSample(x, y, e.latlng);
                } else {
                    this.classifyPixel(x, y, e.latlng);
                }
            }
            
            addTrainingSample(x, y, latlng) {
                if (!this.selectedClass) {
                    this.showStatus('Please select a class first', 'error');
                    return;
                }
                
                // Add training sample
                this.trainingData.push({
                    x: x,
                    y: y,
                    class_id: this.selectedClass.id,
                    latlng: latlng
                });
                
                // Update class count
                this.selectedClass.count++;
                
                // Add marker to map
                const marker = L.circleMarker(latlng, {
                    color: this.selectedClass.color,
                    fillColor: this.selectedClass.color,
                    fillOpacity: 0.8,
                    radius: 4,
                    weight: 2
                }).addTo(this.map);
                
                this.markers.push(marker);
                
                this.updateClassDisplay();
                this.showStatus(`Added training sample for ${this.selectedClass.name}`, 'success');
            }
            
            async classifyPixel(x, y, latlng) {
                if (this.trainingData.length === 0) {
                    this.showStatus('Please add training samples first', 'error');
                    return;
                }
                
                this.showStatus('Classifying pixel...', 'loading');
                
                try {
                    const apiBase = this.getApiBase();
                    const response = await fetch(`${apiBase}/api/get_pixel_embedding`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            lat: this.currentLocation.lat,
                            lon: this.currentLocation.lon,
                            year: this.currentLocation.year,
                            x: x,
                            y: y
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error(result.error);
                    }
                    
                    // For now, show pixel info
                    const stats = result.data.stats;
                    this.showStatus(`Pixel embedding: min=${stats.min.toFixed(3)}, max=${stats.max.toFixed(3)}, mean=${stats.mean.toFixed(3)}`, 'success');
                    
                } catch (error) {
                    console.error('Error classifying pixel:', error);
                    this.showStatus(`Error classifying pixel: ${error.message}`, 'error');
                }
            }
            
            async classifyAllPixels() {
                if (!this.embeddingData || !this.currentLocation) {
                    this.showStatus('Please load embeddings first', 'error');
                    return;
                }
                
                const method = document.getElementById('classificationMethod').value;
                
                if (method === 'knn' && this.trainingData.length === 0) {
                    this.showStatus('Please add training samples for KNN classification', 'error');
                    return;
                }
                
                this.showStatus('Classifying all pixels...', 'loading');
                this.showProgress(0);
                
                try {
                    const apiBase = this.getApiBase();
                    const requestData = {
                        lat: this.currentLocation.lat,
                        lon: this.currentLocation.lon,
                        year: this.currentLocation.year,
                        training_samples: this.trainingData,
                        method: method,
                        threshold: parseFloat(document.getElementById('threshold').value),
                        n_clusters: parseInt(document.getElementById('nClusters').value),
                        class_colors: this.getClassColors()
                    };
                    
                    const response = await fetch(`${apiBase}/api/classify_pixels`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestData)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error(result.error);
                    }
                    
                    this.classificationResults = result.data;
                    
                    // Add classification layer to map
                    this.updateClassificationLayer();
                    
                    // Show classification statistics
                    const stats = result.data.class_stats;
                    const total = Object.values(stats).reduce((sum, count) => sum + count, 0);
                    const classified = total - (stats['-1'] || 0);
                    
                    this.showStatus(`Classification complete! ${classified} of ${total} pixels classified`, 'success');
                    this.hideProgress();
                    
                } catch (error) {
                    console.error('Error classifying pixels:', error);
                    this.showStatus(`Error classifying pixels: ${error.message}`, 'error');
                    this.hideProgress();
                }
            }
            
            updateClassificationLayer() {
                if (!this.classificationResults) return;
                
                // Remove existing classification layer
                if (this.classificationLayer) {
                    this.map.removeLayer(this.classificationLayer);
                }
                
                // Add new classification layer
                const bounds = [
                    [this.currentLocation.lat, this.currentLocation.lon],
                    [this.currentLocation.lat + 0.1, this.currentLocation.lon + 0.1]
                ];
                
                this.classificationLayer = L.imageOverlay(this.classificationResults.visualization, bounds, {
                    opacity: 0.6,
                    interactive: false
                }).addTo(this.map);
            }
            
            getClassColors() {
                const colors = {};
                this.classes.forEach(cls => {
                    colors[cls.id] = cls.color;
                });
                return colors;
            }
            
            addClass() {
                const name = document.getElementById('newClassName').value.trim();
                if (!name) {
                    this.showStatus('Please enter a class name', 'error');
                    return;
                }
                
                const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F'];
                const color = colors[this.classes.length % colors.length];
                
                const newClass = {
                    id: this.classes.length,
                    name: name,
                    color: color,
                    count: 0
                };
                
                this.classes.push(newClass);
                this.selectedClass = newClass; // Auto-select new class
                document.getElementById('newClassName').value = '';
                this.updateClassDisplay();
                this.showStatus(`Added class: ${name}`, 'success');
            }
            
            updateClassDisplay() {
                const classList = document.getElementById('classList');
                classList.innerHTML = '';
                
                this.classes.forEach(classObj => {
                    const div = document.createElement('div');
                    div.className = 'class-item';
                    if (this.selectedClass && this.selectedClass.id === classObj.id) {
                        div.style.border = '2px solid #4CAF50';
                    }
                    
                    div.innerHTML = `
                        <div class="class-color" style="background-color: ${classObj.color}"></div>
                        <div class="class-info">
                            <div class="class-name">${classObj.name}</div>
                            <div class="class-count">${classObj.count} samples</div>
                        </div>
                        <div class="class-actions">
                            <button onclick="classifier.selectClass(${classObj.id})">Select</button>
                            <button onclick="classifier.removeClass(${classObj.id})">Remove</button>
                        </div>
                    `;
                    
                    classList.appendChild(div);
                });
                
                if (this.classes.length === 0) {
                    classList.innerHTML = '<div style="color: #aaa; font-size: 12px;">No classes defined</div>';
                }
            }
            
            selectClass(classId) {
                this.selectedClass = this.classes.find(c => c.id === classId);
                this.updateClassDisplay();
                this.showStatus(`Selected class: ${this.selectedClass.name}`, 'success');
            }
            
            removeClass(classId) {
                // Remove class
                this.classes = this.classes.filter(c => c.id !== classId);
                
                // Remove associated training data
                this.trainingData = this.trainingData.filter(sample => sample.class_id !== classId);
                
                // Remove markers for this class
                this.markers = this.markers.filter(marker => {
                    // This is a simplification - in a real implementation you'd track markers by class
                    return true;
                });
                
                // Clear selected class if it was removed
                if (this.selectedClass && this.selectedClass.id === classId) {
                    this.selectedClass = null;
                }
                
                this.updateClassDisplay();
                this.showStatus('Class removed', 'success');
            }
            
            clearClasses() {
                this.classes = [];
                this.trainingData = [];
                this.selectedClass = null;
                this.classificationResults = null;
                
                // Clear all markers
                this.markers.forEach(marker => this.map.removeLayer(marker));
                this.markers = [];
                
                // Clear classification layer
                if (this.classificationLayer) {
                    this.map.removeLayer(this.classificationLayer);
                    this.classificationLayer = null;
                }
                
                this